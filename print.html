<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hash Programming Language</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="basics/intro.html"><strong aria-hidden="true">2.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">2.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/operators.html"><strong aria-hidden="true">2.2.</strong> Operators &amp; Symbols</a></li><li class="chapter-item expanded "><a href="basics/types.html"><strong aria-hidden="true">2.3.</strong> Types, Structs and Enums</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/primitive-types.html"><strong aria-hidden="true">2.3.1.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basics/struct-types.html"><strong aria-hidden="true">2.3.2.</strong> Struct types</a></li><li class="chapter-item expanded "><a href="basics/enum-types.html"><strong aria-hidden="true">2.3.3.</strong> Enum types</a></li><li class="chapter-item expanded "><a href="basics/generics-polymorphism.html"><strong aria-hidden="true">2.3.4.</strong> Generics and polymorphism</a></li><li class="chapter-item expanded "><a href="basics/types-assertions.html"><strong aria-hidden="true">2.3.5.</strong> Type Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="basics/conditionals.html"><strong aria-hidden="true">2.4.</strong> Conditional statements</a></li><li class="chapter-item expanded "><a href="basics/pattern-matching.html"><strong aria-hidden="true">2.5.</strong> Pattern matching</a></li><li class="chapter-item expanded "><a href="basics/loops.html"><strong aria-hidden="true">2.6.</strong> Loops</a></li><li class="chapter-item expanded "><a href="basics/functions.html"><strong aria-hidden="true">2.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="basics/prelude.html"><strong aria-hidden="true">2.8.</strong> Prelude &amp; Built-in functionality</a></li><li class="chapter-item expanded "><a href="basics/modules.html"><strong aria-hidden="true">2.9.</strong> Modules</a></li></ol></li><li class="chapter-item expanded "><a href="standard-library/intro.html"><strong aria-hidden="true">3.</strong> Standard library</a></li><li class="chapter-item expanded "><a href="interpreter/intro.html"><strong aria-hidden="true">4.</strong> Interpreter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interpreter/options.html"><strong aria-hidden="true">4.1.</strong> Interpreter Options</a></li><li class="chapter-item expanded "><a href="interpreter/backends.html"><strong aria-hidden="true">4.2.</strong> Compiler backends</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/intro.html"><strong aria-hidden="true">5.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/compiler-internals.html"><strong aria-hidden="true">5.1.</strong> Compiler internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/loop-transpilation.html"><strong aria-hidden="true">5.1.1.</strong> Loop transpilation</a></li><li class="chapter-item expanded "><a href="advanced/if-statement-transpilation.html"><strong aria-hidden="true">5.1.2.</strong> If statement transpilation</a></li><li class="chapter-item expanded "><a href="advanced/type-inference.html"><strong aria-hidden="true">5.1.3.</strong> Type inference</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/future-features.html"><strong aria-hidden="true">5.2.</strong> Future features</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Hash Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/hash-org/lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is dedicated to documenting and teaching the <code>Hash</code> programming language to newcommers.</p>
<p>Firstly, Hash is an interpreted, garbage collected, strongly and statically typed language.</p>
<h2 id="prerequisites-about-the-book"><a class="header" href="#prerequisites-about-the-book">Prerequisites about the book</a></h2>
<p>Sections which have the ðŸš§ icon next to the title are likely to change or be re-written in the future
due to the nature of the early age of the language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-basics"><a class="header" href="#language-basics">Language Basics</a></h1>
<p>This chapter is dedicated to the language basics, everything you need to know about the <code>Hash</code> language
to start writing code in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>Variables are made of three distinct components. The variable name, the variable type and the 
literal expression that is assigned to the name.</p>
<p>Declaration and assignment can happen separately:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8;
x = 3;
<span class="boring">}
</span></code></pre></pre>
<p>Variables cannot be used until they are assigned.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8;

print(x) // :^( error
<span class="boring">}
</span></code></pre></pre>
<p>Will result in the compiler error:</p>
<pre><code>error: Failed to typecheck:
 --&gt; 1:5
  |
1 | let x:u8;
  |     ^--- symbol 'x' declared here without initialisation.
  |

 --&gt; 3:7
  |
3 | print(x)
  |       ^
  |   symbol 'x' is uninitialised.
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>The type of a variable, if not given, is automatically inferred by the value.
In <code>let a: X = b</code>, if the type of <code>b</code> is not <code>X</code>, the language produces an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators--symbols"><a class="header" href="#operators--symbols">Operators &amp; Symbols</a></h1>
<p>This section contains all of the syntactic operators that are available within Hash</p>
<h2 id="general-operators-"><a class="header" href="#general-operators-">General operators ðŸš§</a></h2>
<p>Here are the general operators for arithmetic, bitwise assignment operators. This table does not include
all of the possible operators specified within the grammar. There are more operators that are related to
a specific group of operations or are used to convey meaning within the language.</p>
<table><thead><tr><th>Operator</th><th>Example</th><th>Description</th><th>Overloadable trait</th></tr></thead><tbody>
<tr><td><code>===</code>, <code>!==</code></td><td><code>a === b</code>, <code>a !== c</code></td><td>Referential equality</td><td><code>ref_eq</code></td></tr>
<tr><td><code>-&gt;</code></td><td>N/A</td><td><code>Reserved</code></td><td>N/A</td></tr>
<tr><td><code>=&gt;</code></td><td><code>(a) =&gt; a + 2</code></td><td>Function notation</td><td>N/A</td></tr>
<tr><td><code>==</code>, <code>!=</code></td><td><code>a == 2</code>, <code>b != 'a'</code></td><td>Equality</td><td><code>eq</code></td></tr>
<tr><td><code>=</code></td><td><code>a = 2</code></td><td>Assignment</td><td>N/A</td></tr>
<tr><td><code>!</code></td><td><code>!a</code></td><td>Logical not</td><td><code>not</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>a &amp;&amp; b</code></td><td>Logical and</td><td><code>and</code></td></tr>
<tr><td><code>||</code></td><td><code>a  || b</code></td><td>Logical or</td><td><code>or</code></td></tr>
<tr><td><code>+</code></td><td><code>2 + 2</code>, <code>3 + b</code></td><td>Addition</td><td><code>add</code></td></tr>
<tr><td><code>-</code></td><td><code>3 - a</code></td><td>Subtraction</td><td><code>sub</code></td></tr>
<tr><td><code>-</code></td><td><code>-2</code></td><td>Negation</td><td><code>neg</code></td></tr>
<tr><td><code>*</code></td><td><code>3 * 2</code>, <code>2 * c</code></td><td>Multiplication</td><td><code>mul</code></td></tr>
<tr><td><code>^^</code></td><td><code>3 ^^ 2</code>, <code>3 ^^ 2.3</code></td><td>Exponentiation</td><td><code>exp</code></td></tr>
<tr><td><code>/</code></td><td><code>4 / 2</code>, <code>a / b</code></td><td>Division</td><td><code>div</code></td></tr>
<tr><td><code>%</code></td><td><code>a % 1</code></td><td>Modulo</td><td><code>mod</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>4 &lt;&lt; 1</code></td><td>Bitwise left shift</td><td><code>shl</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>8 &gt;&gt; 1</code></td><td>Bitwise right shift</td><td><code>shr</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>5 &amp; 4</code>, <code>a &amp; 2</code></td><td>Bitwise and</td><td><code>andb</code></td></tr>
<tr><td><code>|</code></td><td><code>a  | 2</code></td><td>Bitwise or</td><td><code>orb</code></td></tr>
<tr><td><code>^</code></td><td><code>3 ^ 2</code></td><td>Bitwise exclusive or</td><td><code>xorb</code></td></tr>
<tr><td><code>~</code></td><td><code>~2</code></td><td>Bitwise not</td><td><code>notb</code></td></tr>
<tr><td><code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td><code>2 &lt; b</code>, <code>c &gt;= 3</code></td><td>Order comparison</td><td><code>ord</code></td></tr>
<tr><td><code>+=</code></td><td><code>x += y</code></td><td>Add with assignment</td><td><code>add_eq</code></td></tr>
<tr><td><code>-=</code></td><td><code>x -= 1</code></td><td>Subtract with assignment</td><td><code>sub_eq</code></td></tr>
<tr><td><code>*=</code></td><td><code>b *= 10</code></td><td>Multiply with assignment</td><td><code>mul_eq</code></td></tr>
<tr><td><code>/=</code></td><td><code>b /= 2</code></td><td>Divide with assignment</td><td><code>div_eq</code></td></tr>
<tr><td><code>%=</code></td><td><code>a %= 3</code></td><td>Modulo with assignment</td><td><code>mod_eq</code></td></tr>
<tr><td><code>&amp;&amp;=</code></td><td><code>b &amp;&amp;= c</code></td><td>Logical and with assignment</td><td><code>and_eq</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>b &gt;&gt;= 3</code></td><td>Bitwise right shift equality</td><td><code>shr_eq</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>b &lt;&lt;= 1</code></td><td>Bitwise left shift equality</td><td><code>shl_eq</code></td></tr>
<tr><td><code>||=</code></td><td><code>b ||= c</code></td><td>Logical or with assignment</td><td><code>or_eq</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>a &amp;= b</code></td><td>Bitwise and with assignment</td><td><code>andb</code></td></tr>
<tr><td><code>|=</code></td><td><code>b  |= SOME_CONST</code></td><td>Bitwise or with assignment</td><td><code>orb</code></td></tr>
<tr><td><code>^=</code></td><td><code>a ^= 1</code></td><td>Bitwise xor with assignment</td><td><code>xorb</code></td></tr>
<tr><td><code>.</code></td><td><code>a.foo</code>, <code>item.id</code></td><td>Struct/Tuple enum property accessor</td><td>N/A</td></tr>
<tr><td><code>:</code></td><td><code>{2: 'a'}</code></td><td>Map key-value separator</td><td>N/A</td></tr>
<tr><td><code>::</code></td><td><code>io::open()</code></td><td>Namespace symbol access</td><td>N/A</td></tr>
<tr><td><code>as</code></td><td><code>t as str</code></td><td>Type assertion</td><td>N/A</td></tr>
<tr><td><code>@</code></td><td>N/A</td><td>Pattern value binding</td><td>N/A</td></tr>
<tr><td><code>...</code></td><td>N/A</td><td>Spread operator (Not-implemented)</td><td><code>range</code>?</td></tr>
<tr><td><code>;</code></td><td><code>expression;</code></td><td>statement terminator</td><td>N/A</td></tr>
<tr><td><code>?</code></td><td><code>let k&lt;T&gt; where s&lt;T, ?&gt; = ...</code></td><td>Type argument wildcard</td><td>N/A</td></tr>
</tbody></table>
<h2 id="comments-"><a class="header" href="#comments-">Comments ðŸš§</a></h2>
<p>This table represents the syntax for different types of comments in Hash:</p>
<table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody>
<tr><td><code>//...</code></td><td>Line comment</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment</td></tr>
<tr><td>N/A</td><td>Module/function doc comment</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Types in Hash can be split into three distinct categories, which are:</p>
<ul>
<li><a href="basics/./ch2-02a-types.html">Primitives</a></li>
<li><a href="basics/./ch2-02b-types.html">Structs</a></li>
<li><a href="basics/./ch2-02c-types.html">Enums</a></li>
<li><a href="basics/./ch2-02d-types.html">Generic type arguments</a></li>
<li><a href="basics/./ch2-02e-types.html">Type signature assertions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p>There are the following primitive types:</p>
<ul>
<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>: unsigned integers</li>
<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>: signed integers</li>
<li><code>f32</code>, <code>f64</code> : floating point numbers</li>
<li><code>usize</code>, <code>isize</code>: unsigned and signed native integer types (for list indexing)</li>
<li><code>ibig</code>, <code>ubig</code>: unlimited size integers</li>
<li><code>bool</code>: boolean</li>
<li><code>str</code>: string, copy on write and immutable</li>
<li><code>[A]</code>: a list containing type A</li>
<li><code>{A:B}</code>: a map between type A and type B</li>
<li><code>(A, B, C)</code>: a tuple containing types A, B and C. Elements can be accessed by dot notation (<code>my_tuple.first</code>)</li>
<li><code>void</code>: the empty type. Has a corresponding <code>void</code> value.</li>
<li><code>never</code>: a type which can never be instantiated. Used, for example, for functions that never return, like <code>panic</code>.</li>
</ul>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>Numbers in hash are like numbers in most other statically typed language. Numbers come in 3 variants, 'unsigned', 'signed' and 'floating point'.</p>
<p>Floating point literals must include either a <code>.</code> or a scientific notation exponent
like <code>3.0</code>, <code>3e2</code>, <code>30e-1</code>, etc.</p>
<h3 id="number-types-like-usize--isize--ibig--ubig"><a class="header" href="#number-types-like-usize--isize--ibig--ubig">Number types like <code>usize</code> &amp; <code>isize</code> &amp; <code>ibig</code> &amp; <code>ubig</code></a></h3>
<p>These number primitives are added for convienience when working with a variety of
problems and host operating systems. The primitives <code>usize</code> and <code>isize</code> are intended
for list indexing. This is because on some systems (which are 32bit) may not be able
to support indexing a contiguous region of memory that is larger than '32bit' max value. So, the <code>usize</code> and <code>isize</code> primitives are host system dependent. </p>
<p>The <code>ibig</code> and <code>ubig</code> number primitives are integer types that have no upper
or lower bound and will grow until the host operating system memory is exhausted 
when storing them. These types are intended to be used when working with heavy mathematical problems which may exceed the maximum '64bit' integer boundary.</p>
<h2 id="bracketted-type-syntax"><a class="header" href="#bracketted-type-syntax">Bracketted type syntax</a></h2>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<p>Lists are denoted using the the common square bracket syntax where the values are
separated by commas, like so:</p>
<pre><code class="language-rs">let x = [1,2,3,4,5,6]; // multiple elements
let y = [];
let z = [1,]; // optional trailing comma
</code></pre>
<p>To explictly declare a variable is of a <code>list</code> type, you do so:</p>
<pre><code class="language-rs">let some_list: [u64] = [];
//             ^^^^^
//              type
</code></pre>
<h3 id="tuple"><a class="header" href="#tuple">Tuple</a></h3>
<p>Tuples have a familiar syntax with many other languages, but exhibit two distinct
differences between the common syntax. These differences are:</p>
<ul>
<li>Empty tuples: <code>(,)</code></li>
<li>Singleton tuple : <code>(A,)</code></li>
<li>Many membered tuple: <code>(A, B, C)</code> or <code>(A, B, C,)</code> </li>
</ul>
<p>To explictly declare a variable is of a <code>tuple</code> type, you do so:</p>
<pre><code class="language-rs">let empty_tuple: (,) = (,);
//               ^^^
//               type

let some_tuple: (str, u32) = (&quot;string&quot;, 12);
//              ^^^^^^^^^^
//                 type
</code></pre>
<p><strong>Note</strong>: Trailing commas are not allowed within type defintions.</p>
<p>It's worth noting that tuples are fancy syntax for structures and are indexed
using 'english' numerical phrasing like <code>first</code>, <code>second</code>, <code>third</code>, etc to access
each member explicitly. Although, they are intended to be used mostly for pattern
matching, you can access members of tuples like so. However, you will not be able to access members of tuples that are larger than 10 elements in size. 
If this is the case, you should consider using a structural data type which will
allow you to do the same thing, and name the fields. Read more about patterns <a href="basics/pattern-matching.html">here</a>.</p>
<h3 id="set"><a class="header" href="#set">Set</a></h3>
<p>Like tuples, sets have the same syntactic differences:</p>
<ul>
<li>Empty set: <code>{,}</code></li>
<li>Singleton set : <code>{A,}</code></li>
<li>Many membered set: <code>{A, B, C}</code> or <code>{A, B, C,}</code> </li>
</ul>
<p>To explictly declare a variable is of a <code>set</code> type, you do so:</p>
<pre><code class="language-rs">let some_map: {str} = {,};
//            ^^^^^
//            set type
</code></pre>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>Like tuples, sets have the same syntactic differences:</p>
<ul>
<li>Empty map: <code>{:}</code></li>
<li>Singleton map : <code>{A:1}</code> or <code>{A:1,}</code></li>
<li>Many membered map: <code>{A: 1, B: 2, C: 3}</code> or <code>{A: 1, B: 2, C: 3,}</code> </li>
</ul>
<p>To explictly declare a variable is of a <code>map</code> type, you do so:</p>
<pre><code class="language-rs">let some_map: {str: u8} = {:};
//            ^^^^^^^^^
//            map type
</code></pre>
<h2 id="special-types"><a class="header" href="#special-types">Special types</a></h2>
<ul>
<li>
<p><code>void</code> - A type used to denote that this function does not return anything, for example a function that does some computation and the prints it, whilst having no
return statement or the last statement being the a print statement (which has a void return type signature).</p>
</li>
<li>
<p><code>never</code> - A type that can never be instantiated, passed and interacted with. This
is a special type to annotate functions that will never continue from then onwards.
For example, the provided <code>panic</code> function which will stop the current program from
running and print a stack trace, which cannot return anything since it crashes the 
compiler internally. 
The difference between <code>void</code> and <code>never</code> is that <code>void</code> returns nothing, and <code>never</code>
cannot return anything.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-types"><a class="header" href="#struct-types">Struct types</a></h1>
<p>In Hash, structs are pre-defined collections of heterogeneous types, similar to C or Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vector3 = {
   x: f32;
   y: f32;
   z: f32;
};
<span class="boring">}
</span></code></pre></pre>
<p>A struct is comprised of a set of fields.
Each field has a name, a type, and an optional default value.</p>
<p>Structs can be instantiated with specific values for each of the fields.
Default values can be omitted, but can also be overridden.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dog = {
   age: u32 = 42;
   name: str;
}

let d = Dog { name = &quot;Bob&quot; };

print(d); // Dog { name = &quot;Bob&quot;; age = 42; }
<span class="boring">}
</span></code></pre></pre>
<p>Structs are nominal types.
An argument of type <code>Dog</code> can only be fulfilled by an instance of <code>Dog</code>, and you can't pass in a struct that has the same fields but is of a different logical type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dog_name = (dog: Dog) =&gt; dog.name;

struct FakeDog = {
   age: u32 = 42;
   name: str;
}

print(dog_name(d)); // &quot;Bob&quot;
print(dog_name(FakeDog { age = 1, name = &quot;Max&quot; })); // Error: Type mismatch: was expecting `Dog`, got `FakeDog`.
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-types"><a class="header" href="#enum-types">Enum types</a></h1>
<p>Hash enums are similar to Rust enums or Haskell data types.
Each variant of an enum can also hold some data.
These are also known as <em>algebraic data types</em>, or <em>tagged unions</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum NetworkError = {
   NoBytesReceived;
   ConnectionTerminated;
   Unexpected(str, int);
};
<span class="boring">}
</span></code></pre></pre>
<p>Enum contents consist of a semicolon-separated list of variant names.
Each variant can be paired with some data, in the form of a comma-separated list of types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = NetworkError.Unexpected(&quot;something went terribly wrong&quot;, 32);
<span class="boring">}
</span></code></pre></pre>
<p>They can be <code>match</code>ed to discover what they contain:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle_error = (error: NetworkError) =&gt; match error {
   NoBytesReceived =&gt; print(&quot;No bytes received, stopping&quot;);
   ConnectionTerminated =&gt; print(&quot;Connection was terminated&quot;);
   Unexpected(err, code) =&gt; print(&quot;An unexpected error occured: &quot; + err + &quot; (&quot; + conv(code) + &quot;) &quot;);
};
<span class="boring">}
</span></code></pre></pre>
<p>Like structs, enums are nominal types, rather than structural.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-polymorphism"><a class="header" href="#generics-and-polymorphism">Generics and polymorphism</a></h1>
<p>Hash supports polymorphism through generic types.
These come in two forms:</p>
<ul>
<li>Function traits</li>
<li>Generic structs and enums</li>
</ul>
<h2 id="function-traits"><a class="header" href="#function-traits">Function traits</a></h2>
<p>Function traits are a core mechanic in Hash, which allow for different implementations of the same operation, for different types.
The following code defines a function trait <code>merge</code> which, for some type <code>T</code>, takes two <code>T</code> values and returns a <code>T</code> value.
Generic type names are denoted by single capital letters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait merge = &lt;T&gt; =&gt; (T, T) =&gt; T;
<span class="boring">}
</span></code></pre></pre>
<p>Angular brackets (<code>&lt;</code>, <code>&gt;</code>) define a <em>type argument list</em>, containing one or more generic type names.
These can be used anywhere in the following type expression.</p>
<p>Traits can be implemented for specific types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let merge&lt;str&gt; = (a, b) =&gt; str_concat(a, b);
<span class="boring">}
</span></code></pre></pre>
<p>They can also be implemented for a generic type bound.
The following code implements <code>merge</code> for any type that implements <code>add</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let merge&lt;T&gt; where add&lt;T&gt; = (a, b) =&gt; a + b;
<span class="boring">}
</span></code></pre></pre>
<p>This is called <em>blanket implementation</em> and it can be done using the <code>where</code> keyword.
Note that the code might contain multiple overlapping implementations of the same function trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let merge&lt;T&gt; where add&lt;T&gt; = (a, b) =&gt; a + b;
let merge&lt;u32&gt; = (a, b) =&gt; a + b + 42; // But u32 also implements add!
<span class="boring">}
</span></code></pre></pre>
<p>In that case, for each function trait resolution, the <em>last-declared implementation</em> of the trait has precedence:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print(merge(1 as u8,  2 as u8)); // 3u8
print(merge(1 as u32, 2 as u32)); // 45u32
<span class="boring">}
</span></code></pre></pre>
<p>The <code>add</code> trait is defined in the standard library, and implementations of <code>add</code> for different types define how different types should be added together.
In fact, <code>a + b</code> is just syntactical sugar for <code>add(a, b)</code>.
This is the case for all operators in Hash, which are defined in the <code>op</code> standard library module.</p>
<p>Traits can benefit from type inference:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let simon_says = (what: str) =&gt; merge(&quot;Simon says &quot;, what); // inferred to merge&lt;str&gt;
<span class="boring">}
</span></code></pre></pre>
<p>This is done by looking at:</p>
<ol>
<li>The types of the arguments given.</li>
<li>The surrounding context, for example the expected return value of the expression.</li>
</ol>
<p>Trait implementation bounds can make use of the special <code>?</code> type quantifier, which essentially means &quot;any type&quot;.
For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let skip&lt;I&gt; for next&lt;I, ?&gt; = ...;
<span class="boring">}
</span></code></pre></pre>
<p>says &quot;implement <code>skip&lt;I&gt;</code> for any <code>I</code> that has an implementation <code>next&lt;I, T&gt;</code>, where <code>T</code> is any type&quot;.
Essentially, <code>skip</code> doesn't care about the <code>T</code>, but <code>next</code> still requires a second argument, so <code>?</code> is used.</p>
<h2 id="generic-structs-and-enums"><a class="header" href="#generic-structs-and-enums">Generic structs and enums</a></h2>
<p>Hash also supports generic structs and enums.</p>
<p>These are essentially <em>type functions</em>, which take a type and return another type.</p>
<p>For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result = &lt;T, E&gt; =&gt; {
   Ok(T);
   Err(E);
};
<span class="boring">}
</span></code></pre></pre>
<p>is a generic enum, very similar to Haskell's <code>Either</code> type or Rust's <code>Result</code> type.
It takes two types <code>T</code> and <code>E</code>, and returns a type <code>Result&lt;T, E&gt;</code> representing an operation which succeeds with result <code>T</code>, or fails with error <code>E</code>.
Each instantiation of a generic type is unique and is treated as a completely separate type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let print_result = (r: Result&lt;u32, str&gt;) =&gt; print(conv(r));

let my_res: Result&lt;u16, str&gt; = Ok(&quot;Hello there!&quot;);
print_result(my_res); // Type mis // Error: Type mismatch: was expecting `Result&lt;u32, str&gt;`, got `Result&lt;u16, str&gt;`.
<span class="boring">}
</span></code></pre></pre>
<p>The same pattern is possible with structs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vector3 = &lt;T&gt; =&gt; {
   x: T;
   y: T;
   z: T;
}
<span class="boring">}
</span></code></pre></pre>
<p>Type inference works both for enums and structs.
It can be inferred by the types of the contents, or the expected return value, or both.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let abc = Vector3 { x = 'a'; y = 'b'; z = 'c' }; // Vector3&lt;char&gt;
let maybe_foo = Some(&quot;foo&quot;); // Option&lt;str&gt;
<span class="boring">}
</span></code></pre></pre>
<p>If you want a generic type argument to be inferred, but want to specify another one, you can use the <code>_</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let char_list = &quot;Hello world&quot;.iter().collect&lt;_, [char]&gt;();
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-parameters"><a class="header" href="#generic-parameters">Generic parameters</a></h2>
<p>Generic parameters in Hash work slightly differently than they do in other languages.</p>
<p>For example, one can write:</p>
<pre><code class="language-rs">let next&lt;Enumerate&lt;I&gt;, (usize, T)&gt; where next&lt;I, T&gt;;
</code></pre>
<p>This implements the <code>next</code> trait from the standard library for the <code>Enumerate</code> struct.
Notice that the <code>Enumerate</code> struct takes a generic parameter, which is denoted with <code>I</code>.
Type variables in type argument lists can appear nested within other generic types.
When a type variable appears anywhere within a type argument list, it is implicitly &quot;declared&quot;.</p>
<pre><code class="language-rs">let next&lt;WeirdIterator&lt;I&gt;, I&gt; where next&lt;I, ?&gt;;
</code></pre>
<p>The above snippet implements <code>next</code> for a <code>WeirdIterator</code> struct, generic over some type <code>I</code>.
The element of the iterator is of the same type <code>I</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-signature-assertions"><a class="header" href="#type-signature-assertions">Type Signature Assertions</a></h1>
<h2 id="basics-1"><a class="header" href="#basics-1">Basics</a></h2>
<p>As in many other languages, the programmer can specify the type of a variable or
a literal by using some special syntax. For example, in languages such as typescript,
you can say that: </p>
<pre><code class="language-ts">some_value as str
</code></pre>
<p>which implies that you are asserting that <code>some_value</code> is a string, this is essentially a way to avoid explicitly stating that type of a variable every
single time and telling the compiler &quot;Trust me <code>some_value</code> is a <code>string</code>&quot;. </p>
<p>The principle is somewhat similar in <code>Hash</code>, but it is more strictly enforced.
For example, within the statement <code>let x = 37;</code>, the type of <code>x</code> can be any of the
integer types. This might lead to unexpected behaviour in future statements, where
the compiler has decided the type of <code>x</code> (it might not be what you intended it).</p>
<p>So, you can either declare <code>x</code> to be some integer type explicitly like so:</p>
<pre><code class="language-rs">let x: u32 = 37;
</code></pre>
<p>Or you can, use <code>as</code> to imply a type for a variable, which the compiler will assume 
to be true, like so:</p>
<pre><code class="language-rs">let x = 37 as u32;
</code></pre>
<h2 id="failing-type-assertions"><a class="header" href="#failing-type-assertions">Failing type assertions</a></h2>
<p>If you specify a type assertion, the compiler will either attempt to infer this information from the left-hand side of the <code>as</code> operator
to the right. If the inference results in a different type to the right-hand side, this will raise a typechecking failure. </p>
<p>For example, if you were to specify the expression:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;A&quot; as char
<span class="boring">}
</span></code></pre></pre>
<p>The compiler will report this error as:</p>
<pre><code>error: Failed to typecheck:
--&gt; 1:1 - 1:3
  |
  |
1 | &quot;2&quot; as char
  | ^^^    
  |
Cannot match type 'char' with 'str'.
</code></pre>
<h2 id="usefullness"><a class="header" href="#usefullness">Usefullness</a></h2>
<p>Why are type assertions when there is already type inference within the language? Well, sometimes the type inference
system does not have enough information to infer the types of variables and declarations. 
Type inference may not have enough information when dealing with functions that are generic, so it can sometimes
be useful to assert to the compiler that a given variable is a certain type. </p>
<p>Additionally, whilst the language is in an early stage of maturity and some things that are quirky or broken, type
assertions can come to the rescue and help the compiler to understand your program.</p>
<p>In general, type assertions should be used when the compiler cannot infer the type of some expression with 
the given information and needs assistance. You shouldn't need to use type assertions often.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional statements</a></h2>
<p>Conditional statements in the <code>Hash</code> programming language are very similar to other languages such as Python, Javascript, C and Rust. However, there is one subtle <strong>difference</strong>, which is that the statement provided to a conditional statement must always evaluate to an explicit boolean value. </p>
<h2 id="if-else-statements"><a class="header" href="#if-else-statements">If-else statements</a></h2>
<p>If statements are very basic constructs in Hash. An example of a basic <code>if-else</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// checking if the value 'a' evaluates to being 'true'
if a { print(&quot;a&quot;); } else { print(&quot;b&quot;); }

// using a comparison operator
if b == 2 { print(&quot;b is &quot; + b); } else { print (&quot;b is not &quot; + conv(b)); }
<span class="boring">}
</span></code></pre></pre>
<p>Obviously, this checks if the evaluation of <code>a</code> returns a boolean value. If it does not
evaluate to something to be considered as true, then the block expression defined
at <code>else</code> is executed.</p>
<p>If you want multiple clauses, you can utilise the <code>else-if</code> syntax to define multiple
conditional statements. To use the <code>else-if</code> syntax, you do so like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if b == 2 {
     print(&quot;b is 2&quot;)
} else if b == 3 {
     print(&quot;b is 3&quot;)
} else {
    print(&quot;b isn't 2 or 3 &quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>As mentioned in the introduction, a conditional statement must evaluate an explicit boolean value. The <code>if</code> statement syntax will not infer a boolean value from a statement within <code>Hash</code>. This design feature is motivated by the fact that in many languages, common bugs and mistakes occur with the automatic inference of conditional statements. </p>
<p>An example of an invalid program is:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 12;

if a { print(&quot;a&quot;) }
<span class="boring">}
</span></code></pre></pre>
<h3 id="additional-syntax"><a class="header" href="#additional-syntax">Additional syntax</a></h3>
<p>Furthermore, if you do not want an else statement you can do:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if a { print(&quot;a&quot;) }  // if a is true, then execute
<span class="boring">}
</span></code></pre></pre>
<p>which is syntactic sugar for:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if a { print(&quot;a&quot;) } else {}
<span class="boring">}
</span></code></pre></pre>
<p>Additionally, since the <code>if</code> statement body's are also equivalent to functional bodies, you
can also specifically return a type as you would normally do within a function body:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let abs: (i64: x) =&gt; i64 = if x &lt; 0 { -x } else { x }
<span class="boring">}
</span></code></pre></pre>
<p>However, you cannot do something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let abs: (i64: x) =&gt; i64 = if x &lt; 0 { -x }
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note</strong>: here that you will not get a syntax error if you run this, but you will encounter an error during the interpretation stage of the program because the function may not have any return type since this has no definition
of what should happen for the <code>else</code> case.</p>
<h2 id="if-statements-and-enums-"><a class="header" href="#if-statements-and-enums-">If statements and Enums ðŸš§</a></h2>
<p>You can destruct enum values within if statments using the <code>if-let</code> syntax, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result = &lt;T, E&gt; =&gt; {
   Ok(T);
   Err(E);
};

// mission critical, program should exit if it failed
let result: Result&lt;u16, str&gt; = Ok(12);

if let Ok(value) = result  { 
  print(&quot;Got '&quot; + conv(value) + &quot;' from operation&quot;) 
} else let Err(e) = result {
  panic(&quot;Failed to get result: &quot; + e);
}
<span class="boring">}
</span></code></pre></pre>
<p>Furthermore, for more complicated conditional statements, you can include an expression
block which is essentially treated as if it was a functional body, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: str = &quot;file.txt&quot;;

if { let a = open(f); is_ok(a) } {
    // run if is_ok(a) returns true
}

// the above statement can also be written as
let a = open(f);

if is_ok(a) {
    // run if is_ok(a) returns true
}

<span class="boring">}
</span></code></pre></pre>
<p>The only difference between those two examples is that within the first, a is contained within
the if statement condition body expression, i.e; the <code>a</code> variable will not be visible to any further
scope. This has some advantages, specifically when you don't wish to store that particular result
from the operation. But if you do, you can always use the second version to utilise the result
of <code>a</code> within the <code>if</code> statement body or later on in the program.</p>
<br />
<h2 id="match-cases"><a class="header" href="#match-cases">Match cases</a></h2>
<p>Match cases are one step above the simple <code>if-else</code> syntax.  Using a matching case, you can construct more complicated cases in a more readable format than u can with an <code>if-else</code> statement. Additionally, you can destruct Enums into their corresponding values. To use a matching case, you do the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let a = input&lt;u8&gt;();

let m2 = match a {
  1 =&gt; &quot;one&quot;;
  2 =&gt; &quot;two&quot;;
  _ =&gt; &quot;not one or two&quot;;
}

// Or as a function

let convert: (x: u8) =&gt; str = (x) =&gt; match x {
  1 =&gt; &quot;one&quot;;
  2 =&gt; &quot;two&quot;;
  _ =&gt; &quot;not one or two&quot;;
}

let m = convert(input&lt;u8&gt;());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>_</code> case is a special wildcard case that captures any case. This is essentially synonymous with the <code>else</code> clause in many other languages like Python or JavaScript. For conventional purposes, it should be included when creating a <code>match</code> statement where the type value is not reasonably bounded (like an integer). One subtle difference with the <code>match</code> syntax is you must always explicitly define a <code>_</code> case. This language behaviour is designed to enforce that <code>explicit</code> is better than <code>implicit</code>. So, if you know that a program should never hit
the default case:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match x {
  1 =&gt; &quot;one&quot;;
  2 =&gt; &quot;two&quot;;
  _ =&gt; unreachable(); // we know that 'x' should never be 1 or 2.
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note</strong>: You do not have to provide a default case if you have defined all the cases for a type (this mainly applies to enums).</p>
<p>Additionally, because cases are matched incrementally, by doing the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let convert: (x: u8) =&gt; str = (x) =&gt; match x {
  _ =&gt; &quot;not one or two&quot;;
  1 =&gt; &quot;one&quot;;
  2 =&gt; &quot;two&quot;;
}
<span class="boring">}
</span></code></pre></pre>
<p>The value of <code>m</code> will always evaluate as <code>&quot;not one or two&quot;</code> since the wildcard matches any condition.</p>
<p>Match statements are also really good for destructing enum types in Hash. 
For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result = &lt;T, E&gt; =&gt; {
   Ok(T);
   Err(E);
};

...

// mission critical, program should exit if it failed
let result: Result&lt;u16, str&gt; = Ok(12);

match result {
  Ok(value) =&gt; print(&quot;Got '&quot; + conv(value) + &quot;' from operation&quot;);
  Err(e)    =&gt; panic(&quot;Failed to get result: &quot; + e);
}
<span class="boring">}
</span></code></pre></pre>
<p>To specify multiple conditions for a single case within a <code>match</code> statement, you can do so by
writing the following syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = input&lt;u32&gt;();

match x {
  1 | 2 | 3       =&gt; print(&quot;x is 1, 2, or 3&quot;);
  4 | 5 | {2 | 4} =&gt; print(&quot;x is either 4, 5 or 6&quot;); // using bitwise or operator
  _               =&gt; print(&quot;x is something else&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>To specify more complex conditional statements like and within the match case, you
can do so using the <code>match-if</code> syntax, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = input&lt;u32&gt;();
let y: bool = true;

match x {
  1 | 2 | 3 if y =&gt; print(&quot;x is 1, 2, or 3 when y is true&quot;);
  {4 if y} | y   =&gt; print(&quot;x is 4 and y is true, or  x is equal to y&quot;); // using bitwise or operator
  {2 | 4 if y}   =&gt; print(&quot;x is 6 and y is true&quot;);
  _              =&gt; print(&quot;x is something else&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h1>
<p>Pattern matching is a very big part of <code>Hash</code> and the productivity of the language. Pattern
matching can come in two main forms: literal patterns and destructuring patterns.</p>
<p>Pattern matching within <code>match</code> statements is more detailed within the <a href="basics/./conditionals.html#match-cases">Conditional statements</a> section
of the book. This chapter is dedicated to documenting the various ways to use patterns.</p>
<h2 id="literal-patterns"><a class="header" href="#literal-patterns">Literal patterns</a></h2>
<p>Literal patterns are can be used within <code>match</code> statements to compare a subject expression to a literal. For example,
consider the following snippet of code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = conv&lt;int&gt;(input());

match x {
    Some(1) =&gt; print(&quot;That's a one!&quot;);
    Some(2) =&gt; print(&quot;You entered 2&quot;);
    Some(n) =&gt; print(n + &quot; is greater than 1 and 2&quot;); // &lt;- binding literal pattern
    _ =&gt; print(&quot;You didn't enter a number&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>On the left-hand side there are literal patterns that include literal values, which <code>x</code> will be compared
to. Literal patterns follow the same syntax to binding patterns. Additionally, literal patterns can include
binding elements such as the third condition in the <code>match</code> statement: <code>Some(n) =&gt; ...</code> where <code>n</code> is the bind
to the literal.</p>
<h2 id="destructuring-patterns"><a class="header" href="#destructuring-patterns">Destructuring patterns</a></h2>
<p>Destructuring patterns are used to assign parts of an object to seperate variables within <code>let</code>, <code>for</code>, and
<code>match</code>statements. A very simple example of a destructuring pattern in a <code>let</code> statement would be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup = (1, 2); // 2D point

let (x, y) = tup; // x=1, y=2
<span class="boring">}
</span></code></pre></pre>
<p>In this example, the <code>x</code> and <code>y</code> variables are binding to the components of the tuple <code>tup</code>.
After destructuring <code>tup</code> you can continue to use <code>tup</code> with the addition of using the binds
that were created in the statement. This feature is very handy when it comes to data structures
that are fairly complicated and large, and you only want to use three or four components
from the whole structure. </p>
<blockquote>
<p><strong>Note</strong>: When you are destructuring components that are represented as references, they are not
copied but represented as referenced, pattern binds can be thought of as just shorthand for 
assigning named fields to individual symbols with the same names.</p>
</blockquote>
<p>Similarly to <code>let</code> statements, <code>for</code> statements can also utilise destructuring patterns:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Point = {
    x: int,
    y: int
}

let points = [Point {x=1, y=2}, Point {x=3, y=2}, Point {x=-1, y=7}, ...];

for Point {x, y} in points.iter() {
    print(sqrt(x*x + y*y))
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see within the <code>for</code> loop, the pattern <code>Point{x, y}</code> is being used to
destruct each point in the array into the seperate fields.</p>
<h2 id="struct-patterns"><a class="header" href="#struct-patterns">Struct patterns</a></h2>
<p>Struct patterns follow a simiar syntax to struct literals in Hash. You can discard and
access fields available within a struct by specifiying the field name and then followed
by an optional right-hand side pattern to either rename the field or use a literal pattern.</p>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<p>Struct patterns can be used in both literals and destructuring contexts. To destructure a struct
within a <code>let</code> statement, you specify the name of the struct (it can be namespaced as well), and then
specify the binding fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Point {x, y} = my_point;
<span class="boring">}
</span></code></pre></pre>
<p>You can also use struct literal patterns within a <code>match</code> statement:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Person = {
    name: str;
    age: int;
    height: float;
    sex: char;
};

let p = Person {
    name = &quot;John&quot;;
    age = 23;
    height = 1.89;
    sex = 'M';
};

match p {
    Person { name = &quot;John&quot;, age } =&gt; {
        print(&quot;John's age is &quot; ++ conv(age));
    };
    Person { name = &quot;Sarah&quot;, age } =&gt; {
        print(&quot;Sarah's age is &quot; ++ conv(age))
    };
    Person { age } =&gt; { 
        print(&quot;The other person's age is &quot; ++ conv(age))
    };
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="renaming-fields"><a class="header" href="#renaming-fields">Renaming fields</a></h3>
<p>In the example, we want to rename one of the fields to a custom binding name:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Car = {
    name: str,
    id: int,
    ...
}

let compare_id = (car: Car, id: int) =&gt; {
    // destruct the 'id' out of car and rename it
    let Car {id = car_id} = car;

    id == car_id
}
<span class="boring">}
</span></code></pre></pre>
<p>So, in the above example (which is admittedly unrealistic) we rename the cars <code>id</code> field to
<code>car_id</code> by specifing the right-hand side binding pattern <code>= car_id</code>.</p>
<h2 id="namespace-patterns"><a class="header" href="#namespace-patterns">Namespace patterns</a></h2>
<p>Namspace patterns are very similar to struct patterns, but they can only be used within <code>let</code>
statements and when importing symbols from other modules. They follow a simple syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imports only a and b from the module
let {a, b} = import(&quot;./my_lib&quot;);

// imports 'c' as my_c, and 'd' from the module.
let {c: my_c, d} = import(&quot;./other_lib&quot;); 
<span class="boring">}
</span></code></pre></pre>
<p>To read more about modules, you can click <a href="basics/./modules.html">here</a>.</p>
<h2 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple patterns</a></h2>
<p>Tuple patterns are straight forward, they follow the same syntax as declaring a tuple literal.</p>
<p>To ignore some parts of the tuple, you can use the <code>_</code> (ignore) operator to throw away parts of the
tuple. For example, if a 3-element sized tuple was provided and you only want to use the second element,
you can do:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tri_group: (int, float, str)
let (_, n, _) = tri_group;
<span class="boring">}
</span></code></pre></pre>
<p>Pattern matching on tuples is also currently the only way to work with tuples that are sized 9 elements
or greater. The language supports tuples that are sized larger than 9 elements, however it does not
support accessing each element via the property access. So, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>excessive_tup.tenth; // error
let (_, _, _, _, _, _, _, _, _, tenth) =  excessive_tup;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: You shouldn't use tuples this large, this leads to code that is difficult to read and interpret,
you should use a struct in that case which would solve the complexities of your data structures.</p>
</blockquote>
<h2 id="array-patterns-"><a class="header" href="#array-patterns-">Array patterns ðŸš§</a></h2>
<p>Array patterns are currently not implemented within the language, but are planned to be added.</p>
<p>An array pattern can bind elements at certain positions of the array by using the following syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>Now in this example, the compiler will assume that the size of <code>arr</code> is of length 2, and if not it will error since
parts of the array are essentially unhandeled. To circumvent this issue you can use the <code>...</code>, (spread) operator which
used as a capturing group for some elements. With the example above, you can ignore all of the following elements after
the first two by writing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b, ...] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>If you want to assign the remaining elements to some bind, you can specify an identifier after the <code>spread</code> operator like
so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b, ...rest] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>If you want to bind elements at the end of the array, you can use the <code>spread</code> operator at the start of the pattern
to ignore or capture the elements like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [..., a, b] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>Assign the last two elements of the array to <code>a</code> and <code>b</code> respectively.</p>
<p>One obvious limitation of the <code>spread</code> operator is that you can only use it once in the array pattern.
For example, the following pattern will be reported as an error by the compiler:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [..., a, ...] = arr;
<span class="boring">}
</span></code></pre></pre>
<pre><code>error: Failed to Typecheck:
 --&gt; 1:6 - 1:9, 1:15 - 1:18
  |
1 | let [..., a, ...] = arr;
  |      ^^^     ^^^
  |
  = You cannot use multiple spread operators within a single array pattern.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-constructs"><a class="header" href="#loop-constructs">Loop constructs</a></h1>
<p>Hash contains 3 distinct loop control constructs: <code>for</code>, <code>while</code> and <code>loop</code>. Each construct has
a distinct usage case, but they can often be used interchangebly without hastle and are merely
a style choice.</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>Each construct supports the basic <code>break</code> and <code>continue</code> loop control flow statements. These statements
have the same properties as in many other languages like C, Rust, Python etc.</p>
<p><code>break</code> - Using this control flow statements immediatelly terminates the loop and continues
to any statement after the loop (if any).</p>
<p><code>continue</code> - Using this control flow statement will immediatelly skip the current iteration
of the loop body and move on to the next iteration (if any). Obviously, if no iterations
remain, <code>continue</code> behaves just like <code>break</code>.</p>
<h2 id="for-loop"><a class="header" href="#for-loop">For loop</a></h2>
<h3 id="basics-2"><a class="header" href="#basics-2">Basics</a></h3>
<p>For loops are special loop control statements that are designed to be used
with iterators. </p>
<p>For loops can be defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in range(1, 10) { // range is a built in iterator
    print(i);
}
<span class="boring">}
</span></code></pre></pre>
<p>Iterating over lists is also quite simple using the <code>iter</code> function to 
convert the list into an iterator:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nums: [u32] = [1,2,3,4,5,6,7,8,9,10]; 

// infix functional notation
for num in nums.iter() {
    print(num);
}

// using the postfix functional notation
for num in iter(nums) {
    print(nums);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="iterators"><a class="header" href="#iterators">iterators</a></h3>
<p>Iterators ship with the standard library, but you can define your own iterators via the Hash generic typing system.</p>
<p>An iterator <code>I</code> of <code>T</code> it means to have an implementation <code>next&lt;I, T&gt;</code> in scope the current scope. 
So, for the example above, the <code>range</code> function is essentially a <code>RangeIterator</code> of the <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>...</code> types.</p>
<p>More details about generics are <a href="basics/./generics-polymorphism.html">here</a>.</p>
<h2 id="while-loop"><a class="header" href="#while-loop">While loop</a></h2>
<h3 id="basics-3"><a class="header" href="#basics-3">Basics</a></h3>
<p>While loops are identical to 'while' constructs in other languages such as Java, C, JavaScript, etc.
The loop will check a given conditional expression ( must evaluate to a <code>bool</code>), and if it evaluates
to <code>true</code>, the loop body is executed, oterhwise the interpreter moves on. The loop body can also
use loop control flow statements like <code>break</code> or <code>continue</code> to prematurely stop looping for a
given condition.</p>
<p>While loops can be defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let c: u32 = 0;

while c &lt; 10 {
    print(i);
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>loop</code> keyword is equivalent of someone writing a <code>while</code> loop that has
a conditional expression that always evaluate to <code>true</code>; like so,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while true {
    // do something
}

// is the same as...

loop {
    // do something
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: In <code>Hash</code>, you cannot write <code>do-while</code> loops, but if u want to write a loop that behaves
like a <code>do-while</code> statement, here is a good example using <code>loop</code>:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>loop {
    // do something here, to enable a condition check,
    // and then use if statement, or match case to check
    // if you need to break out of the loop.

    if !condition {break}
}    
<span class="boring">}
</span></code></pre></pre>
<h3 id="expression-blocks-and-behaviour"><a class="header" href="#expression-blocks-and-behaviour">Expression blocks and behaviour</a></h3>
<p>Furthermore, The looping condition can also be represented as a block which means it can have any number of expressions
before the final expression. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while {c += 1; c &lt; 10} {
    print(i);
}
<span class="boring">}
</span></code></pre></pre>
<p>It is worth noting that the looping expression whether block or not must explicitly have the 
<code>boolean</code> return type. For example, the code below will fail typechecking:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c: u32 = 100;

while c -= 1 {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Running the following code snippet produces the following error:</p>
<pre><code>error: Failed to Typecheck:
 --&gt; 3:7 - 3:12
  |
3 | while c -= 1 {
  |       ^^^^^^
  |       Expression does not have a boolean type 
</code></pre>
<h2 id="loop"><a class="header" href="#loop">Loop</a></h2>
<p>The loop consturct is the simplest of the three. The basic syntax for a loop is as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let c: u64 = 1;

loop {
    print(&quot;I looped &quot; + c + &quot; times!&quot;);
    c += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also use conditional statements within the loop body (which is equivalent to a function body) like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let c: u64 = 1;

loop {
    if c == 10 { break }

    print(&quot;I looped &quot; + c + &quot; times!&quot;);
    c += 1;
} // this will loop 10 times, and print all 10 times
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c: u64 = 1;

loop {
    c += 1;
    if c % 2 != 0 { continue };

    print(&quot;I loop and I print when I get a  &quot; + c);
} // this will loop 10 times, and print only when c is even
<span class="boring">}
</span></code></pre></pre>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:docs/loops.md</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<p>As mentioned at the start of the introduction, the <code>loop</code> control flow keyword
is the most universal control flow since to you can use <code>loop</code> to represent 
both the <code>for</code> and <code>while</code> loops. </p>
<h3 id="for-loop-transpillation"><a class="header" href="#for-loop-transpillation">for loop transpillation</a></h3>
<p>Since <code>for</code> loops are used for iterators in hash, we transpile the construct into
a primitive loop. An iterator can be traversed by calling the <code>next</code> function on the
iterator. Since <code>next</code> returns a <code>Option</code> type, we need to check if there is a value
or if it returns <code>None</code>. If a value does exist, we essentially perform an assignment
to the pattern provided. If <code>None</code>, the branch immediatelly breaks the <code>for</code> loop.
A rough outline of what the transpillation process for a <code>for</code> loop looks like:</p>
<p>For example, the <code>for</code> loop can be expressed using <code>loop</code> as:</p>
<pre><code>for &lt;pat&gt; in &lt;iterator&gt; {
    &lt;block&gt;
}

// converted to
loop {
    match next(&lt;iterator&gt;) {
        Some(&lt;pat&gt;) =&gt; &lt;block&gt;;
        None        =&gt; break;
    }
}
</code></pre>
<p>An example of the transpillation process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = [1,2,3,5].into_iter();

for x in i {
    print(&quot;x is &quot; + x);
}


// the same as...
let i = [1,2,3,5].into_iter();

loop {
  match next(i) {
    Some(x) =&gt; {print(&quot;x is &quot; + x)};
    None =&gt; break;
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="while-loop-internal-representation"><a class="header" href="#while-loop-internal-representation">While loop internal representation</a></h3>
<p>In general, a while loop transpilation process occurs by transferring the looping 
condition into a match block, which compares a boolean condition. If the boolean
conditionb evaluates to <code>false</code>, the loop will immediatelly <code>break</code>. Otherwise
the body expression is exected. A rough outline of what the transpillation process for a <code>while</code> loop looks like:</p>
<pre><code>while &lt;condition&gt; {
    &lt;block&gt;
}

// converted to
loop {
    match &lt;condition&gt; {
        true  =&gt; &lt;block&gt;;
        false =&gt; break;
    }
}
</code></pre>
<p>This is why the condition must explicitly return a boolean value.</p>
<p>An example of a transpilation:</p>
<p>And the <code>while</code> loop can be written using the <code>loop</code> directive
like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = 0;

loop {
    match c &lt; 5 { // where 'x' is the condition for the while loop
        true  =&gt; c += 1;
        false =&gt; break;
    }
}

// same as...
let c = 0;

while c &lt; 5 {
    c+=1;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="loop-construct"><a class="header" href="#loop-construct">Loop construct</a></h3>
<p>Similarly, the <code>loop</code> keyword is equivalent of someone writing a <code>while</code> loop that has
a conditional expression that always evaluate to <code>true</code>; like so,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while true {
    // do something
}

// is the same as...

loop {
    // do something
}
<span class="boring">}
</span></code></pre></pre>
<p>=======
&gt;&gt;&gt;&gt;&gt;&gt;&gt; main:docs/src/basics/loops.md</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p><code>Hash</code> places a lot of emphasis on functions, which are first class citizens.
Functions can be assigned to variables in the same way that any other value is stored, similar to languages like Python, JavaScript, etc.
In fact, the way to define a function is to assign it to a variable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fib = (n: u32) =&gt; 
   if n == 1 || n == 2 {
       n
   } else {
       fib(n - 1) + fib(n - 2)
   };

print(fib) // &lt;function at ____&gt;
print(fib(3)) // 3
<span class="boring">}
</span></code></pre></pre>
<p>Multiple arguments can be specified:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let str_eq = (a: str, b: str) =&gt; a == b;
<span class="boring">}
</span></code></pre></pre>
<p>The type of a function can be specified in a similar way:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let str_eq: (str, str) =&gt; str = (a, b) =&gt; a == b;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prelude"><a class="header" href="#prelude">Prelude</a></h1>
<p>Prelude is a module that is automatically loaded in with any module because it contains language constructs
that are essential for any <code>Hash</code> program to run.</p>
<p>The source to prelude is available <a href="https://github.com/hash-org/lang/blob/main/stdlib/prelude.hash">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-language-modules"><a class="header" href="#hash-language-modules">Hash language modules</a></h1>
<p>A module in <code>Hash</code> is equivalent to a namespace that can contain variable definitions, function definitions, type definitions or include other modules.</p>
<h2 id="importing"><a class="header" href="#importing">Importing</a></h2>
<p>Given the project structure:</p>
<pre><code>.
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ a.hash
â”‚   â”œâ”€â”€ b.hash
â”‚   â””â”€â”€ sub
â”‚       â””â”€â”€ c.hash
â””â”€â”€ main.hash
</code></pre>
<p>Modules in hash allow for a source to be split up into smaller code fragments, allowing for better source code organisation and maintainance.</p>
<p>You can import modules by specifying the path relative to the current path. </p>
<p>For example, if you wanted to include the modules <code>a</code>, <code>b</code>, and or <code>c</code> within your main file</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.hash
let a = import(&quot;lib/a&quot;);
let b = import(&quot;lib/b&quot;);
let c = import(&quot;lib/sub/c&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>By doing so, you are placing everything that is defined within each of those modules under
the namespace. </p>
<h2 id="referencing-exports-"><a class="header" href="#referencing-exports-">Referencing exports ðŸš§</a></h2>
<blockquote>
<p><strong>Note</strong>: Currently there is no way to declare if a symbol or type are to be exported or should be contained within the local scope of the module. Of course this is bounded to change and hence why the name <code>pub</code> has been reserved for the future.</p>
</blockquote>
<p>Furthermore, if the <code>a</code> module contained a structure definition like <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a.hash
struct Point = {
    x: u32;
    y: u32;
}
<span class="boring">}
</span></code></pre></pre>
<p>Within main, you can create a new <code>point</code> by doing the following</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.hash
let a = import(&quot;lib/a&quot;);

let p1 = a::Point { x=2; y=3 };

print(p1.x); // 2
print(p1.y); // 3
<span class="boring">}
</span></code></pre></pre>
<p>So from this example, you use the <code>::</code> (namespace access operator) to reference any exports from the module.</p>
<p>Furthermore, what if you wanted to import only a specific definition within a module such as the 'Point' structure from the module <code>a</code>.</p>
<p>You can do so by destructuring the definitions into using the syntax as
follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let {Point} = import(&quot;lib/a&quot;);

let p1 = Point { x=2; y=3 };
<span class="boring">}
</span></code></pre></pre>
<p>In case you have a member of your current module already reserving a name, you
can rename the exported members to your liking:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let {Point: LibPoint} = import(&quot;lib/a&quot;);

let p1 = LibPoint { x=2; y=3 };
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: Naming is entirely up to the developer, there are no restrictions on naming
except the language naming </p>
</blockquote>
<h3 id="cyclic-imports-"><a class="header" href="#cyclic-imports-">Cyclic imports ðŸš§</a></h3>
<p>Hash does not currently support cyclical dependencies within a project. Two modules within a project cannot be dependent on each other. As much as this might be an inconvienience, this is done to avoid &quot;behaviour&quot; which is implied by supporting cyclical imports. Other languages such as JavaScript support cyclical imports but can sometimes exhibit strange behaviour when using modules with cyclical imports.</p>
<p>It is currently under consideration to lift this restriction, but at the same time avoid strange behaviours when supporting cyclical imports.</p>
<p>If you attempt to run a module which has a cyclical import, the compiler will error and refuse to run the module like so:</p>
<pre><code class="language-sh">$ hash -e ./module_with_cyclic_imports.hash
error: Found circular dependency in &quot;./module_with_cyclic_imports.hash&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard library</a></h1>
<h2 id="current-modules"><a class="header" href="#current-modules">Current modules</a></h2>
<p>The standard library included the following modules:</p>
<ul>
<li><code>math</code>: Mathematical functions, constants and over useful numerical methods.</li>
<li><code>io</code>: File handling and IO module</li>
<li><code>iter</code>: Iterators module</li>
<li><code>list</code>: Useful list functions including sorting, manipulation and transformations</li>
</ul>
<h2 id="future-expansions-"><a class="header" href="#future-expansions-">Future expansions ðŸš§</a></h2>
<p>These modules are currently under construction or proposed:</p>
<ul>
<li><code>time</code>: Useful constrcuts for time orientated data</li>
<li><code>sys</code>: System information about the host OS</li>
<li><code>path</code>: Path utilities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h1>
<p>This chapter is dedicated to documenting the current interpreter implementation, future plans and a
very basic manual for how to use the interpeter (via commandline arguments).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpretor-command-line-arguments"><a class="header" href="#interpretor-command-line-arguments">Interpretor command-line arguments</a></h1>
<p>The <code>Hash</code> interpreter has a number of options that you can enable when running an instance of
a VM. This page documents options and configurations that you can change when running a <code>Hash</code>
interpreter. </p>
<h1 id="general-overview"><a class="header" href="#general-overview">General overview</a></h1>
<h2 id="-e---execute-execute-a-command"><a class="header" href="#-e---execute-execute-a-command"><code>-e</code>, <code>--execute</code>: Execute a command</a></h2>
<p>Set the mode of the interpreter to 'execute' mode implying to immediately run the provided script rather than launching as an interactive mode. </p>
<p>For example:</p>
<pre><code>$ hash -e examples/compute_pi.hash
3.1415926535897
</code></pre>
<h2 id="-d---debug-run-compiler-in-debug-mode"><a class="header" href="#-d---debug-run-compiler-in-debug-mode"><code>-d</code>, <code>--debug</code>: Run compiler in debug mode</a></h2>
<p>This will enable debug mode within the compiler which will mean that the compiler will verbosely report on timings, procedures and in general
what it is doing at a given moment.</p>
<h2 id="-h---help-print-commandline-help-menu"><a class="header" href="#-h---help-print-commandline-help-menu"><code>-h</code>, <code>--help</code>: Print commandline help menu</a></h2>
<p>Displays a help dialogue on how to use the command line arguments with the hash interpreter. </p>
<h2 id="-v---version-compiler-version"><a class="header" href="#-v---version-compiler-version"><code>-v</code>, <code>--version</code>: Compiler version</a></h2>
<p>Displays the current interpreter version with some additional debug information about the installed interpreter.</p>
<h1 id="vm-specific-options"><a class="header" href="#vm-specific-options">VM Specific options</a></h1>
<h2 id="-s---stack-size-adjust-vm-stack-size"><a class="header" href="#-s---stack-size-adjust-vm-stack-size"><code>-s</code>, <code>--stack-size</code>: Adjust vm stack size</a></h2>
<p>Adjust the stack size of the Virtual Machine. Default value is <code>10,0000</code></p>
<h1 id="debug-modes"><a class="header" href="#debug-modes">Debug Modes</a></h1>
<h2 id="ast-gen-generate-ast-from-input-file-only"><a class="header" href="#ast-gen-generate-ast-from-input-file-only"><code>ast-gen</code>: Generate AST from input file only</a></h2>
<p>This mode tells the compiler to finish at the Abstract Syntax Tree stage and not produce any other kind of output.</p>
<h2 id="ir-gen--generate-ir-from-input-file-only"><a class="header" href="#ir-gen--generate-ir-from-input-file-only"><code>ir-gen</code>: : Generate IR from input file only</a></h2>
<p>This mode tells the compiler to finish at the IR stage and not produce any other kind of output.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-backends"><a class="header" href="#compiler-backends">Compiler backends</a></h1>
<h2 id="current-backend"><a class="header" href="#current-backend">Current backend</a></h2>
<p>The current backend uses a Bytecode representation of the program which will run in a Virtual
machine that implements garbage collection. This is similar to Python's approach to running
programs, but however as we all know, Python is incredibly terrible for performant code 
(unless using C bindings).</p>
<p>We want to move away from using a Virtual machine as the main backend and actually provide
executables that can be run on <code>x86_64</code> backend using either a native (naive) backend, and
LLVM.</p>
<p>However, there are advantages to having a VM implementation for the language, which are 
primarily:</p>
<ul>
<li>We can have an interactive mode, execute code on the fly (with a minor performance hit)</li>
<li>We can run compile-time code functions that are beyound just templates and constant
folding expressions.</li>
</ul>
<h2 id="planned-backends"><a class="header" href="#planned-backends">Planned backends</a></h2>
<p>Here are the currently planned backends, that will be worked on and stabalised some time in the future:</p>
<table><thead><tr><th>Name</th><th>Description</th><th>Target platform</th><th>Status</th></tr></thead><tbody>
<tr><td><code>x86_64_native</code></td><td>A native backend for generating executables and performing optimisations ourselves.</td><td><code>x86_64</code></td><td>âŒ</td></tr>
<tr><td><code>x86_64_llvm</code></td><td>An backend powered by the might of LLVM backend.</td><td><code>x86_64</code></td><td>âŒ</td></tr>
<tr><td><code>vm</code></td><td>Virtual machine backend able to run bytecode compiled programs.</td><td><code>any</code></td><td>âœ…</td></tr>
<tr><td><code>elf64</code></td><td>Backend for generating standalone ELFs for un-named host operating systems.</td><td><code>i386</code></td><td>âŒ</td></tr>
<tr><td><code>wasm</code></td><td>WebAssembly backend, convert hash programs into WebAssembly executables</td><td><code>browser/any</code></td><td>âŒ</td></tr>
<tr><td><code>js</code></td><td>JS backend, generate TS/JavaScript code from the provided program.</td><td><code>browser/any</code></td><td>âŒ</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<p>This chapter of the book is dedicated to documenting advanced concepts for developers and contributers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-internals"><a class="header" href="#compiler-internals">Compiler internals</a></h1>
<p>This chapter is dedicated to documenting some core internal features of the compiler which
are note worthy and should be examined by individuals who are interested in more than using
the language but contributing to it's development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-transpilation"><a class="header" href="#loop-transpilation">Loop transpilation</a></h1>
<p>As mentioned at the start of the <a href="advanced/./../basics/loops.html">loops</a> section in the <a href="advanced/./../basics/intro.html">basics</a> chapter, the <code>loop</code> control flow keyword
is the most universal control flow since to you can use <code>loop</code> to represent 
both the <code>for</code> and <code>while</code> loops. </p>
<h3 id="for-loop-transpillation-1"><a class="header" href="#for-loop-transpillation-1">for loop transpillation</a></h3>
<p>Since <code>for</code> loops are used for iterators in hash, we transpile the construct into
a primitive loop. An iterator can be traversed by calling the <code>next</code> function on the
iterator. Since <code>next</code> returns a <code>Option</code> type, we need to check if there is a value
or if it returns <code>None</code>. If a value does exist, we essentially perform an assignment
to the pattern provided. If <code>None</code>, the branch immediatelly breaks the <code>for</code> loop.
A rough outline of what the transpillation process for a <code>for</code> loop looks like:</p>
<p>For example, the <code>for</code> loop can be expressed using <code>loop</code> as:</p>
<pre><code>for &lt;pat&gt; in &lt;iterator&gt; {
    &lt;block&gt;
}

// converted to
loop {
    match next(&lt;iterator&gt;) {
        Some(&lt;pat&gt;) =&gt; &lt;block&gt;;
        None        =&gt; break;
    }
}
</code></pre>
<p>An example of the transpillation process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = [1,2,3,5].into_iter();

for x in i {
    print(&quot;x is &quot; + x);
}


// the same as...
let i = [1,2,3,5].into_iter();

loop {
  match next(i) {
    Some(x) =&gt; {print(&quot;x is &quot; + x)};
    None =&gt; break;
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="while-loop-internal-representation-1"><a class="header" href="#while-loop-internal-representation-1">While loop internal representation</a></h3>
<p>In general, a while loop transpilation process occurs by transferring the looping 
condition into a match block, which compares a boolean condition. If the boolean
conditionb evaluates to <code>false</code>, the loop will immediatelly <code>break</code>. Otherwise
the body expression is exected. A rough outline of what the transpillation process for a <code>while</code> loop looks like:</p>
<pre><code>while &lt;condition&gt; {
    &lt;block&gt;
}

// converted to
loop {
    match &lt;condition&gt; {
        true  =&gt; &lt;block&gt;;
        false =&gt; break;
    }
}
</code></pre>
<p>This is why the condition must explicitly return a boolean value.</p>
<p>An example of a transpilation:</p>
<p>And the <code>while</code> loop can be written using the <code>loop</code> directive
like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = 0;

loop {
    match c &lt; 5 { // where 'x' is the condition for the while loop
        true  =&gt; c += 1;
        false =&gt; break;
    }
}

// same as...
let c = 0;

while c &lt; 5 {
    c+=1;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-statement-transpilation"><a class="header" href="#if-statement-transpilation">If Statement transpilation</a></h1>
<p>As mentioned at the start of the conditionals section in the basics chapter, if statements can be
represnted as <code>match</code> statements. This is especially adviced when you have many <code>if</code> branched and 
more complicated branch conditions.</p>
<p>Internally, the compiler will convert <code>if</code> statements into match cases so that it has to do
less work in the following stages of compilation.</p>
<p>In general, transpilation process can be represented as:</p>
<pre><code>if &lt;condition_1&gt; {
     &lt;block_1&gt; 
} else if &lt;condition_2&gt; { 
    &lt;block_2&gt; 
} 
... 
} else {
    &lt;block_n&gt;
}

// will be converted to

match true {
    _ if &lt;condition_1&gt; =&gt; block_1;
    _ if &lt;condition_2&gt; =&gt; block_3;
    ...
    _ =&gt; block_n;
}
</code></pre>
<p>For example, the following <code>if</code> statment will be converted as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if conditionA {
  print(&quot;conditionA&quot;)
} else if conditionB {
  print(&quot;conditionB&quot;)
} else {
  print(&quot;Neither&quot;)
}

// Internally, this becomes:

match true {
  _ if conditionA =&gt; { print(&quot;conditionA&quot;) };
  _ if conditionB =&gt; { print(&quot;conditionB&quot;) };
  _ =&gt; { print(&quot;Neither&quot;) };
}
<span class="boring">}
</span></code></pre></pre>
<p>However, this representation is not entirely accurate because the compiler will optimise out some components
out of the transpiled version. Redundant statements such as <code>match true { ... }</code> will undergo constant folding
to produce more optimal AST representations of the program.</p>
<h2 id="missing-else-case"><a class="header" href="#missing-else-case">Missing 'else' case</a></h2>
<p>If the <code>if</code> statement lacks an <code>else</code> clause or a default case branch, the compiler will insert one automatically
to avoid issues with pattern exhaustiveness. This behaviour is designed to mimic the control flow of classic <code>if</code>
statements because the <code>else</code> branch will have an assigned empty expression block.</p>
<p>From the above example, but without the <code>else</code> branch:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if conditionA {
  print(&quot;conditionA&quot;)
} else if conditionB {
  print(&quot;conditionB&quot;)
}

// Internally, this becomes:

match true {
  _ if conditionA =&gt; { print(&quot;conditionA&quot;) };
  _ if conditionB =&gt; { print(&quot;conditionB&quot;) };
  _ =&gt; { };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference-1"><a class="header" href="#type-inference-1">Type inference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-features"><a class="header" href="#future-features">Future features</a></h1>
<p>This page is dedicated to documenting future planned features within the language.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
