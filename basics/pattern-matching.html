<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pattern matching - The Hash Programming Language</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../basics/intro.html"><strong aria-hidden="true">2.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">2.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/operators.html"><strong aria-hidden="true">2.2.</strong> Operators &amp; Symbols</a></li><li class="chapter-item expanded "><a href="../basics/types.html"><strong aria-hidden="true">2.3.</strong> Types, Structs and Enums</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/primitive-types.html"><strong aria-hidden="true">2.3.1.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="../basics/struct-types.html"><strong aria-hidden="true">2.3.2.</strong> Struct types</a></li><li class="chapter-item expanded "><a href="../basics/enum-types.html"><strong aria-hidden="true">2.3.3.</strong> Enum types</a></li><li class="chapter-item expanded "><a href="../basics/generics-polymorphism.html"><strong aria-hidden="true">2.3.4.</strong> Generics and polymorphism</a></li><li class="chapter-item expanded "><a href="../basics/types-assertions.html"><strong aria-hidden="true">2.3.5.</strong> Type Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="../basics/conditionals.html"><strong aria-hidden="true">2.4.</strong> Conditional statements</a></li><li class="chapter-item expanded "><a href="../basics/pattern-matching.html" class="active"><strong aria-hidden="true">2.5.</strong> Pattern matching</a></li><li class="chapter-item expanded "><a href="../basics/loops.html"><strong aria-hidden="true">2.6.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../basics/functions.html"><strong aria-hidden="true">2.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../basics/prelude.html"><strong aria-hidden="true">2.8.</strong> Prelude &amp; Built-in functionality</a></li><li class="chapter-item expanded "><a href="../basics/modules.html"><strong aria-hidden="true">2.9.</strong> Modules</a></li></ol></li><li class="chapter-item expanded "><a href="../standard-library/intro.html"><strong aria-hidden="true">3.</strong> Standard library</a></li><li class="chapter-item expanded "><a href="../interpreter/intro.html"><strong aria-hidden="true">4.</strong> Interpreter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interpreter/options.html"><strong aria-hidden="true">4.1.</strong> Interpreter Options</a></li><li class="chapter-item expanded "><a href="../interpreter/backends.html"><strong aria-hidden="true">4.2.</strong> Compiler backends</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced/intro.html"><strong aria-hidden="true">5.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/compiler-internals.html"><strong aria-hidden="true">5.1.</strong> Compiler internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/loop-transpilation.html"><strong aria-hidden="true">5.1.1.</strong> Loop transpilation</a></li><li class="chapter-item expanded "><a href="../advanced/if-statement-transpilation.html"><strong aria-hidden="true">5.1.2.</strong> If statement transpilation</a></li><li class="chapter-item expanded "><a href="../advanced/type-inference.html"><strong aria-hidden="true">5.1.3.</strong> Type inference</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced/future-features.html"><strong aria-hidden="true">5.2.</strong> Future features</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Hash Programming Language</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/hash-org/lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h1>
<p>Pattern matching is a very big part of <code>Hash</code> and the productivity of the language. Pattern
matching can come in two main forms: literal patterns and destructuring patterns.</p>
<p>Pattern matching within <code>match</code> statements is more detailed within the <a href="./conditionals.html#match-cases">Conditional statements</a> section
of the book. This chapter is dedicated to documenting the various ways to use patterns.</p>
<h2 id="literal-patterns"><a class="header" href="#literal-patterns">Literal patterns</a></h2>
<p>Literal patterns are can be used within <code>match</code> statements to compare a subject expression to a literal. For example,
consider the following snippet of code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = conv&lt;int&gt;(input());

match x {
    Some(1) =&gt; print(&quot;That's a one!&quot;);
    Some(2) =&gt; print(&quot;You entered 2&quot;);
    Some(n) =&gt; print(n + &quot; is greater than 1 and 2&quot;); // &lt;- binding literal pattern
    _ =&gt; print(&quot;You didn't enter a number&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>On the left-hand side there are literal patterns that include literal values, which <code>x</code> will be compared
to. Literal patterns follow the same syntax to binding patterns. Additionally, literal patterns can include
binding elements such as the third condition in the <code>match</code> statement: <code>Some(n) =&gt; ...</code> where <code>n</code> is the bind
to the literal.</p>
<h2 id="destructuring-patterns"><a class="header" href="#destructuring-patterns">Destructuring patterns</a></h2>
<p>Destructuring patterns are used to assign parts of an object to seperate variables within <code>let</code>, <code>for</code>, and
<code>match</code>statements. A very simple example of a destructuring pattern in a <code>let</code> statement would be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup = (1, 2); // 2D point

let (x, y) = tup; // x=1, y=2
<span class="boring">}
</span></code></pre></pre>
<p>In this example, the <code>x</code> and <code>y</code> variables are binding to the components of the tuple <code>tup</code>.
After destructuring <code>tup</code> you can continue to use <code>tup</code> with the addition of using the binds
that were created in the statement. This feature is very handy when it comes to data structures
that are fairly complicated and large, and you only want to use three or four components
from the whole structure. </p>
<blockquote>
<p><strong>Note</strong>: When you are destructuring components that are represented as references, they are not
copied but represented as referenced, pattern binds can be thought of as just shorthand for 
assigning named fields to individual symbols with the same names.</p>
</blockquote>
<p>Similarly to <code>let</code> statements, <code>for</code> statements can also utilise destructuring patterns:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Point = {
    x: int,
    y: int
}

let points = [Point {x=1, y=2}, Point {x=3, y=2}, Point {x=-1, y=7}, ...];

for Point {x, y} in points.iter() {
    print(sqrt(x*x + y*y))
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see within the <code>for</code> loop, the pattern <code>Point{x, y}</code> is being used to
destruct each point in the array into the seperate fields.</p>
<h2 id="struct-patterns"><a class="header" href="#struct-patterns">Struct patterns</a></h2>
<p>Struct patterns follow a simiar syntax to struct literals in Hash. You can discard and
access fields available within a struct by specifiying the field name and then followed
by an optional right-hand side pattern to either rename the field or use a literal pattern.</p>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<p>Struct patterns can be used in both literals and destructuring contexts. To destructure a struct
within a <code>let</code> statement, you specify the name of the struct (it can be namespaced as well), and then
specify the binding fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Point {x, y} = my_point;
<span class="boring">}
</span></code></pre></pre>
<p>You can also use struct literal patterns within a <code>match</code> statement:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Person = {
    name: str;
    age: int;
    height: float;
    sex: char;
};

let p = Person {
    name = &quot;John&quot;;
    age = 23;
    height = 1.89;
    sex = 'M';
};

match p {
    Person { name = &quot;John&quot;, age } =&gt; {
        print(&quot;John's age is &quot; ++ conv(age));
    };
    Person { name = &quot;Sarah&quot;, age } =&gt; {
        print(&quot;Sarah's age is &quot; ++ conv(age))
    };
    Person { age } =&gt; { 
        print(&quot;The other person's age is &quot; ++ conv(age))
    };
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="renaming-fields"><a class="header" href="#renaming-fields">Renaming fields</a></h3>
<p>In the example, we want to rename one of the fields to a custom binding name:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Car = {
    name: str,
    id: int,
    ...
}

let compare_id = (car: Car, id: int) =&gt; {
    // destruct the 'id' out of car and rename it
    let Car {id = car_id} = car;

    id == car_id
}
<span class="boring">}
</span></code></pre></pre>
<p>So, in the above example (which is admittedly unrealistic) we rename the cars <code>id</code> field to
<code>car_id</code> by specifing the right-hand side binding pattern <code>= car_id</code>.</p>
<h2 id="namespace-patterns"><a class="header" href="#namespace-patterns">Namespace patterns</a></h2>
<p>Namspace patterns are very similar to struct patterns, but they can only be used within <code>let</code>
statements and when importing symbols from other modules. They follow a simple syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imports only a and b from the module
let {a, b} = import(&quot;./my_lib&quot;);

// imports 'c' as my_c, and 'd' from the module.
let {c: my_c, d} = import(&quot;./other_lib&quot;); 
<span class="boring">}
</span></code></pre></pre>
<p>To read more about modules, you can click <a href="./modules.html">here</a>.</p>
<h2 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple patterns</a></h2>
<p>Tuple patterns are straight forward, they follow the same syntax as declaring a tuple literal.</p>
<p>To ignore some parts of the tuple, you can use the <code>_</code> (ignore) operator to throw away parts of the
tuple. For example, if a 3-element sized tuple was provided and you only want to use the second element,
you can do:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tri_group: (int, float, str)
let (_, n, _) = tri_group;
<span class="boring">}
</span></code></pre></pre>
<p>Pattern matching on tuples is also currently the only way to work with tuples that are sized 9 elements
or greater. The language supports tuples that are sized larger than 9 elements, however it does not
support accessing each element via the property access. So, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>excessive_tup.tenth; // error
let (_, _, _, _, _, _, _, _, _, tenth) =  excessive_tup;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: You shouldn't use tuples this large, this leads to code that is difficult to read and interpret,
you should use a struct in that case which would solve the complexities of your data structures.</p>
</blockquote>
<h2 id="array-patterns-"><a class="header" href="#array-patterns-">Array patterns 🚧</a></h2>
<p>Array patterns are currently not implemented within the language, but are planned to be added.</p>
<p>An array pattern can bind elements at certain positions of the array by using the following syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>Now in this example, the compiler will assume that the size of <code>arr</code> is of length 2, and if not it will error since
parts of the array are essentially unhandeled. To circumvent this issue you can use the <code>...</code>, (spread) operator which
used as a capturing group for some elements. With the example above, you can ignore all of the following elements after
the first two by writing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b, ...] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>If you want to assign the remaining elements to some bind, you can specify an identifier after the <code>spread</code> operator like
so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b, ...rest] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>If you want to bind elements at the end of the array, you can use the <code>spread</code> operator at the start of the pattern
to ignore or capture the elements like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [..., a, b] = arr;
<span class="boring">}
</span></code></pre></pre>
<p>Assign the last two elements of the array to <code>a</code> and <code>b</code> respectively.</p>
<p>One obvious limitation of the <code>spread</code> operator is that you can only use it once in the array pattern.
For example, the following pattern will be reported as an error by the compiler:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [..., a, ...] = arr;
<span class="boring">}
</span></code></pre></pre>
<pre><code>error: Failed to Typecheck:
 --&gt; 1:6 - 1:9, 1:15 - 1:18
  |
1 | let [..., a, ...] = arr;
  |      ^^^     ^^^
  |
  = You cannot use multiple spread operators within a single array pattern.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../basics/conditionals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../basics/loops.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../basics/conditionals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../basics/loops.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
